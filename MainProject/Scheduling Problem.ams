## ams_version=1.0

Model Main_EmployeeAssignment {
	Comment: {
		"Keywords:
		Employee assignment problem, scheduling."
	}
	Section Data_Model {
		Section Quantities_and_Units {
			Comment: {
				"This section contains all the units and quantities that are added automatically by AIMMS.
				It is recommended to declare all your quantities here."
			}
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: {
					minute->s : #-># * 60,
					day->s : #-># * 86400
				}
				Comment: {
					"Expresses the value for the duration of periods.
					
					The unit s has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit minute has been added automatically because it is a required unit for AimmsWebUI.
					
					The unit day has been added automatically because it is a required unit for calendar \"c_days\"."
				}
			}
		}
		Section Inputs {
			Section Calendars {
				Calendar c_days {
					Index: i_day;
					Unit: day;
					BeginDate: sp_todayDate;
					EndDate: sp_yearLaterDate;
					TimeslotFormat: "%c%y-%m-%d";
				}
				StringParameter sp_todayDate {
					Definition: {
						CurrentToString("%c%y-%m-%d");
					}
				}
				StringParameter sp_tomorrowDate {
					Definition: {
						MomentToString("%c%y-%m-%d",
						    [day],
						    sp_todayDate,
						    1[day]);
					}
				}
				StringParameter sp_yearLaterDate {
					Definition: {
						(val(CurrentToString("%c%y")) + 1)
						+ CurrentToString("-%m-%d")
					}
				}
			}
			Section Shifts {
				Set s_shifts {
					Index: i_sh;
					Parameter: ep_selectedShift;
				}
				Parameter p_activeShift {
					IndexDomain: i_sh;
					Range: binary;
				}
				Parameter p_startTime {
					IndexDomain: (i_sh);
				}
			}
			Section Skills {
				Set s_skills {
					Index: i_sk;
					Parameter: ep_selectedSkill;
				}
				Parameter p_activeSkill {
					IndexDomain: i_sk;
					Range: binary;
				}
			}
			Section Restaurants {
				Set s_restaurants {
					Index: i_rest;
					Parameter: ep_selectedRestaurant;
					OrderBy: i_rest;
				}
				Parameter p_activeRestaurant {
					IndexDomain: i_rest;
					Range: binary;
				}
				StringParameter sp_restaurantDescription {
					IndexDomain: i_rest;
				}
				Parameter p_demand {
					IndexDomain: (i_rest,i_sh,i_sk);
					Text: "The needed number of skilled employees in the restaurants";
				}
			}
			Section Employees {
				Set s_employees {
					Index: i_empl;
					Parameter: ep_selectedEmployee;
				}
				Parameter p_activeEmployee {
					IndexDomain: i_empl;
					Range: binary;
				}
				StringParameter sp_employeeDescription {
					IndexDomain: i_empl;
				}
				Parameter p_employeeHasSkill {
					IndexDomain: (i_empl,i_sk);
					Text: "Employees\' skills";
					Range: binary;
				}
				Parameter p_employeeSkillPreference {
					IndexDomain: (i_empl,i_sk) | p_employeeHasSkill(i_empl,i_sk);
					Text: "Job preferences of the employees (lower number means preferred position)";
				}
				Parameter p_employeeDoesShift {
					IndexDomain: (i_empl,i_sh);
					Text: "Employees\' availability for shifts";
					Range: binary;
				}
			}
		}
		Section Math_Model {
			Variable v_assignment {
				IndexDomain: (i_rest,i_empl,i_sh,i_sk);
				Text: "Employees\' work schedule";
				Range: binary;
			}
			Variable v_unfulfilled {
				IndexDomain: (i_rest,i_sh,i_sk);
				Text: "Unfulfilled positions";
				Range: nonnegative;
			}
			Constraint c_satisfyDemand {
				IndexDomain: (i_rest,i_sh,i_sk);
				Text: "The number of assigned employees has to be equal to the needed number of employees minus the unfulfilled positions";
				Definition: {
					sum(i_empl, v_assignment(i_rest,i_empl,i_sh,i_sk)) 
					= 
					p_demand(i_rest,i_sh,i_sk) 
					- 
					v_unfulfilled(i_rest,i_sh,i_sk)
				}
			}
			Constraint c_assignmentSatisfiesShift {
				IndexDomain: (i_empl,i_sh);
				Text: "If the employee is aviable for a shift, then he or she can be assigned, else not";
				Definition: {
					sum((i_rest,i_sk), v_assignment(i_rest,i_empl,i_sh,i_sk)) 
					<= 
					p_employeeDoesShift(i_empl,i_sh)
				}
			}
			Constraint c_assignmentSatisfiesSkills {
				IndexDomain: (i_rest,i_empl,i_sh,i_sk);
				Text: "If the employee has the needed skill for a postion, he or she can be assigned, else not";
				Definition: {
					v_assignment(i_rest,i_empl,i_sh,i_sk) 
					<= 
					p_employeeHasSkill(i_empl,i_sk)
				}
			}
			Constraint c_maximumOfOneShift {
				IndexDomain: (i_empl);
				Text: "An employee cannot do more then one shift";
				Definition: {
					sum((i_rest,i_sh,i_sk),v_assignment(i_rest,i_empl,i_sh,i_sk)) 
					<= 
					1
				}
			}
			Parameter p_unfulfilledWeightingFactor {
				Text: "The cost factor of an unfulfilled postion";
				InitialData: 1000;
			}
			Variable v_unfulfilledCost {
				Text: "The total cost caused by unfulfilled postions";
				Definition: {
					sum((i_rest,i_sh,i_sk), 
					    v_unfulfilled(i_rest,i_sh,i_sk) 
					    * p_unfulfilledWeightingFactor)
				}
			}
			Variable v_notPreferenceCost {
				Text: "The total cost caused by assigning employees for less preferred postions";
				Definition: {
					sum((i_rest,i_empl,i_sh,i_sk), 
					    v_assignment(i_rest,i_empl,i_sh,i_sk) 
					    * p_employeeSkillPreference(i_empl,i_sk))
				}
			}
			Variable v_totalCost {
				Text: "The total cost of the schedule";
				Definition: v_unfulfilledCost + v_notPreferenceCost;
			}
			MathematicalProgram mp_minimizeCost {
				Objective: v_totalCost;
				Direction: minimize;
			}
			DeclarationSection Model_Information {
				ElementParameter ep_programStatus {
					Range: AllSolutionStates;
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Parameter p_gap {
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Parameter p_numberOfContraints {
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Parameter p_numberOfVariables {
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
				Parameter p_solutionTime {
					InitialData: 0;
					webui::FlagsIdentifier: sp_readOnlyFlag;
				}
			}
		}
		Section Outputs {
			Parameter p_assignment {
				IndexDomain: (i_rest, i_empl, i_sh, i_sk);
				Definition: v_assignment(i_rest, i_empl, i_sh, i_sk);
			}
		}
	}
	Section UI_Declarations {
		Procedure pr_empty;
		StringParameter sp_logo {
			Definition: "aimms_logo.png";
		}
		Section Workflow {
			StringParameter sp_myWorkflows {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexWorkflowSpec);
			}
			StringParameter sp_myWorkflowSteps {
				IndexDomain: (webui::indexWorkflowOrder,webui::indexNoOfPages,webui::indexWorkflowPageSpec);
				Definition: {
					data 
					{ ( 1, 1, displayText       ) : "Welcome"            ,  ( 1, 1, icon              ) : "aimms-happy"        ,
					  ( 1, 1, pageId            ) : "home"               ,  ( 1, 1, tooltip           ) : "welcome"            ,
					  ( 1, 1, workflowPageState ) : "active"             ,  ( 1, 1, pageDataState     ) : "Incomplete"         ,
					  ( 1, 1, redirectPageId    ) : "home"               ,  ( 1, 2, displayText       ) : "Story"              ,
					  ( 1, 2, icon              ) : "aimms-lamp5"        ,  ( 1, 2, pageId            ) : "story"              ,
					  ( 1, 2, tooltip           ) : "Problem description",  ( 1, 2, workflowPageState ) : "active"             ,
					  ( 1, 2, pageDataState     ) : "Incomplete"         ,  ( 1, 2, redirectPageId    ) : "home"               ,
					  ( 1, 3, displayText       ) : "Master"             ,  ( 1, 3, icon              ) : "aimms-equalizer2"   ,
					  ( 1, 3, pageId            ) : "inputs"             ,  ( 1, 3, tooltip           ) : "Master data"        ,
					  ( 1, 3, workflowPageState ) : "active"             ,  ( 1, 3, pageDataState     ) : "Incomplete"         ,
					  ( 1, 3, redirectPageId    ) : "home"               ,  ( 1, 4, displayText       ) : "Transactional"      ,
					  ( 1, 4, icon              ) : "aimms-equalizer2"   ,  ( 1, 4, pageId            ) : "transactional_data" ,
					  ( 1, 4, tooltip           ) : "Transactional data" ,  ( 1, 4, workflowPageState ) : "active"             ,
					  ( 1, 4, pageDataState     ) : "Incomplete"         ,  ( 1, 4, redirectPageId    ) : "home"               ,
					  ( 1, 5, displayText       ) : "Results"            ,  ( 1, 5, icon              ) : "aimms-make-group"   ,
					  ( 1, 5, pageId            ) : "results"            ,  ( 1, 5, tooltip           ) : "Model outputs"      ,
					  ( 1, 5, workflowPageState ) : "active",!if (not p_solutionTime) then "inactive" else "active" endif,
					  ( 1, 5, pageDataState     ) : "Incomplete"         ,
					  ( 1, 5, redirectPageId    ) : "home"               ,  ( 1, 6, displayText       ) : "Gantt"              ,
					  ( 1, 6, icon              ) : "aimms-wall"         ,  ( 1, 6, pageId            ) : "gantt"              ,
					  ( 1, 6, tooltip           ) : "Gantt chart"        ,  ( 1, 6, workflowPageState ) : "active",!if (not p_solutionTime) then "inactive" else "active" endif,
					  ( 1, 6, pageDataState     ) : "Incomplete"         ,  ( 1, 6, redirectPageId    ) : "home"                }
				}
				Comment: {
					"\"active\",!if (not p_solutionTime) then \"inactive\" else \"active\" endif,"
				}
			}
		}
		Section Pages {
			Section Master_Page {
				DeclarationSection Master_PageAction {
					StringParameter sp_masterSecondaryActions {
						IndexDomain: (webui::indexPageExtension,webui::indexPageActionSpec);
						Definition: {
							data 
							{ ( 1, displaytext ) : "Import"                ,  ( 1, icon        ) : "aimms-database-insert" ,
							  ( 1, procedure   ) : "pr_importExcelData"    ,  ( 1, state       ) : "active"                ,
							  ( 2, displaytext ) : "Export"                ,  ( 2, icon        ) : "aimms-database-export" ,
							  ( 2, state       ) : "active"                ,  ( 3, displaytext ) : "Generate Random"       ,
							  ( 3, icon        ) : "aimms-database-refresh",  ( 3, state       ) : "active"                ,
							  ( 4, displaytext ) : "Solve"                 ,  ( 4, icon        ) : "aimms-cog"             ,
							  ( 4, procedure   ) : "mainexecution"         ,  ( 4, state       ) : "active"                 }
						}
					}
				}
			}
			Section Transactional_Page {
				DeclarationSection Transactional_PageAction {
					StringParameter sp_transactionalSecondaryActions {
						IndexDomain: (webui::indexPageExtension,webui::indexPageActionSpec);
						Definition: {
							data 
							{ ( 1, displaytext ) : "Import"                ,  ( 1, icon        ) : "aimms-database-insert" ,
							  ( 1, procedure   ) : "pr_importExcelData"    ,  ( 1, state       ) : "active"                ,
							  ( 2, displaytext ) : "Export"                ,  ( 2, icon        ) : "aimms-database-export" ,
							  ( 2, state       ) : "active"                ,  ( 3, displaytext ) : "Generate Random"       ,
							  ( 3, icon        ) : "aimms-database-refresh",  ( 3, state       ) : "active"                ,
							  ( 4, displaytext ) : "Solve"                 ,  ( 4, icon        ) : "aimms-cog"             ,
							  ( 4, procedure   ) : "mainexecution"         ,  ( 4, state       ) : "active"                 }
						}
					}
				}
			}
			Section Results_Page {
				StringParameter sp_resultsSidePanel {
					IndexDomain: (webui::indexPageExtension,webui::indexSidePanelSpec);
					Definition: {
						data 
						{ ( 1, displayText ) : "KPIs"             ,  ( 1, pageId      ) : "informations"     ,
						  ( 1, icon        ) : "aimms-question"   ,  ( 1, state       ) : "active"           ,
						  ( 2, displayText ) : "Model Information",  ( 2, pageId      ) : "model_information",
						  ( 2, icon        ) : "aimms-info"       ,  ( 2, state       ) : "active"            }
					}
				}
			}
			Section Gantt_Page {
				Parameter p_restaurantStartTime {
					IndexDomain: (i_rest, i_empl, i_sh, i_sk) | p_assignment(i_rest,i_empl,i_sh,i_sk);
					Definition: p_startTime(i_sh);
				}
				Parameter p_restaurantDuration {
					IndexDomain: (i_rest,i_empl,i_sh,i_sk) | p_assignment(i_rest,i_empl,i_sh,i_sk);
					Definition: 8;
				}
			}
		}
		Section FlagsIdentifier {
			StringParameter sp_readOnlyFlag {
				Definition: "readonly";
			}
		}
	}
	Section Database_Connection {
		StringParameter sp_connectionString {
			Definition: {
				SQLCreateConnectionString (
				    DatabaseInterface              :  'odbc',
				    DriverName                     :  "SQLite3 ODBC Driver",
				    DatabaseName                   :  "test.db", !The path of your database
				    AdditionalConnectionParameters :  "") ;
			}
		}
		Procedure pr_readAll {
			Body: {
				pr_readSkillDB;
				pr_readShiftDB;
				pr_readEmployeeDB;
				pr_readRestaurantDB;
				pr_readEmployeeShiftsDB;
				pr_readEmployeeSkillDB;
				pr_readDemandDB;
			}
		}
		Procedure pr_writeAll;
		Section DB_Skills {
			DatabaseTable db_readSkills {
				DataSource: sp_connectionString;
				TableName: "skill";
				Mapping: {
					"id"     -->i_sk,
					"active" -->p_activeSkill( i_sk )
				}
			}
			Procedure pr_readSkillDB {
				Body: {
					read from table db_readSkills;
				}
			}
		}
		Section DB_Shifts {
			DatabaseTable db_readShifts {
				DataSource: sp_connectionString;
				TableName: "shift";
				Mapping: {
					"id"         -->i_sh,
					"active"     -->p_activeShift(i_sh),
					"start_time" -->p_startTime(i_sh)
				}
			}
			Procedure pr_readShiftDB {
				Body: {
					read from table db_readShifts;
				}
			}
		}
		Section DB_Employee {
			DatabaseTable db_readEmployees {
				DataSource: sp_connectionString;
				TableName: "employee";
				Mapping: {
					"id"          -->i_empl,
					"active"      -->p_activeEmployee(i_empl),
					"description" -->sp_employeeDescription( i_empl )
				}
			}
			Procedure pr_readEmployeeDB {
				Body: {
					read from table db_readEmployees;
				}
			}
		}
		Section DB_Restaurant {
			DatabaseTable db_readRestaurants {
				DataSource: sp_connectionString;
				TableName: "restaurant";
				Mapping: {
					"id"          -->i_rest,
					"active"      -->p_activeRestaurant(i_rest),
					"description" -->sp_restaurantDescription(i_rest)
				}
			}
			Procedure pr_readRestaurantDB {
				Body: {
					read from table db_readRestaurants;
				}
			}
		}
		Section DB_Employee_Shift {
			DatabaseTable db_readEmployeeShifts {
				DataSource: sp_connectionString;
				TableName: "employee_shift";
				Mapping: {
					"employee_id" -->i_empl,
					"shift_id"    -->i_sh,
					"value"       -->p_employeeDoesShift
				}
			}
			Procedure pr_readEmployeeShiftsDB {
				Body: {
					read from table db_readEmployeeShifts;
				}
			}
		}
		Section DB_Employee_Skill {
			DatabaseTable db_readEmployeeSkills {
				DataSource: sp_connectionString;
				TableName: "employee_skill";
				Mapping: {
					"employee_id"      -->i_empl,
					"skill_id"         -->i_sk,
					"has_skill"        -->p_employeeHasSkill,
					"skill_preference" -->p_employeeSkillPreference
				}
			}
			Procedure pr_readEmployeeSkillDB {
				Body: {
					read from table db_readSkills;
				}
			}
		}
		Section DB_Demand {
			DatabaseTable db_readDemands {
				DataSource: sp_connectionString;
				TableName: "demand";
				Mapping: {
					"restaurant_id" -->i_rest,
					"skill_id"      -->i_sk,
					"shift_id"      -->i_sh,
					"demand"        -->p_demand
				}
			}
			Procedure pr_readDemandDB {
				Body: {
					read from table db_readDemands;
				}
			}
		}
	}
	Section OLD {
		DeclarationSection Initial_Data_Declaration {
			Assertion Check_AtLeastOneSkill {
				IndexDomain: i_empl;
				Text: "Every employee has to have at least one skill";
				Definition: sum(i_sk,p_employeeHasSkill(i_empl,i_sk)) > 0;
				Action: {
					p_employeeHasSkill(i_empl,Element(s_skills,round(uniform(0.5,Card(s_skills)+0.5)))) := 1;
				}
			}
			Assertion Check_AtLeastOneShift {
				IndexDomain: i_empl;
				Text: "Every employee has to do at least one shift";
				Definition: sum(i_sh,p_employeeDoesShift(i_empl,i_sh)) > 0;
				Action: {
					p_employeeDoesShift(i_empl,Element(s_shifts,round(uniform(0.5,Card(s_shifts)+0.5)))) := 1;
				}
			}
		}
		Function EmployeeName {
			Range: string;
			Body: {
				nameID := Round(Uniform(0.5,Card(FirstNames) + 0.49));
				newName := FormatString("%e",Element(FirstNames,nameID));
				nameID := Round(Uniform(0.5,Card(LastNames)+ 0.49));
				newName += FormatString(" %e",Element(LastNames,nameID));
				
				EmployeeName := newName;
			}
			Comment: "Function for generating an employee name";
			Set FirstNames {
				Index: fn;
				InitialData: data{Joe, Ed, Mary, Zoe, Clara, Pete, Carlos, Edith, Robert, Thomas, Sue, Ellen, Ann};
			}
			Set LastNames {
				Index: ln;
				InitialData: data{A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T};
			}
			Parameter nameID;
			StringParameter newName;
		}
	}
	Procedure MainInitialization {
		Body: {
			s_restaurants :=
			  data {'Black Bull Steak Restaurant', 'Smiling Cat Irish Pub', 'Pancake Heaven',
			                'Restaurant At The Corner', 'Vegetable Garden', 'Pizza House',
			                'Full Moon Restaurant'};
			
			while (Card(s_employees) < 200) do
			        SetElementAdd(s_employees,ep_selectedEmployee,EmployeeName);
			endwhile;
			
			s_shifts :=
			   data { Night, Morning, Afternoon };
			
			p_startTime :=
			   data { Night: 0, Morning : 8,  Afternoon : 16 };
			
			s_skills :=
			   data{ Waiter, Cook, Cashier, 'Dish Washer', 'Table Cleaner' };
			
			p_demand(i_rest,i_sh,i_sk) := round(Uniform(0,4));
			p_employeeDoesShift(i_empl,i_sh) := round(uniform(0,1)/3*4);
			p_employeeHasSkill(i_empl,i_sk) := round(uniform(0,1)/3*4);
			
			assert Check_AtLeastOneShift;
			assert Check_AtLeastOneSkill;
			
			p_employeeSkillPreference(i_empl,i_sk) := round(uniform(0.5,3.49));
			
			ep_selectedRestaurant := first(s_restaurants);
			ep_selectedEmployee := first (s_employees);
		}
	}
	Procedure MainExecution {
		Body: {
			solve mp_minimizeCost;
		}
		ElementParameter ACase {
			Range: AllCases;
		}
	}
	Procedure MainTermination {
		Body: {
			return 1;
		}
	}
}
